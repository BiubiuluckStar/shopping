## day1
### 文件夹详述
node_modules文件夹：项目依赖文件
public文件夹：一般放置一些静态资源（图片），需要注意，放在public文件的静态资源，webpack打包时会原封不动的打包到dist文件夹中
  src文件夹
   assets文件夹：一般放置静态资源（一般放置多个组件共用的静态资源，在webpack打包时，webpack会把静态资源当作一个模块，打包js文件里面
component文件夹：一般防止的是非路由组件（全局组件）
App.vue：唯一的根组件
main.js：程序的入口文件，也是整个程序当中最先执行的文件
babel.config.js文件：配置文件（babel相关，将es6转换为es5，使兼容性更好）
package.json文件：认为项目的身份证，记录项目叫什么，项目当中有哪些依赖
package-lock.json文件：缓存性的文件
md文件：说明性文件

## 项目的其他配置
1.项目运行起来的时候，让浏览器自动打开
  -package.json  "serve": "vue-cli-service serve --open",
2.eslint校验功能关闭
在vue.config.js中添加 
  // 关闭eslint
  lintOnSave:false
3.src文件夹简写方式，配置别名
  jsconfig.json配置别名@【@代表是src文件夹】
  "paths": {
      "@/*": [
        "src/*"
      ]
    },
## 项目路由的分析
  vue-router
  前端所谓路由：KV键值对
  key：URL(地址栏的路径)
  value:相应的路由组件
  路由组件：
  Home首页的路由组件：search路由组件,login登录路由，register注册路由组件
  非路由组件：
  Header,Footer【在首页和搜索页有，但是在登陆页面和注册页面并没有】
  ## 开发项目步骤
  1.书写静态页面
  2.拆分组件(结构+样式+资源图片)
  3。获取服务器的数据动态展示
  4.完成相对应的动态业务逻辑
  注意1：创建组件的时候，组件结构+样式+图片资源
  注意2：项目采用的是less样式，浏览器不识别less样式，需要通过less,less-loader[5版本]进行处理less，将less变为css样式

  1.引入一般组件
  2.路由组件搭建
   1.安装vue-router，vue2用3版本，3用4版本
   2.配置路由，项目当中配置的路由一般放置在router文件夹下
  ## 总结
  1.路由组件与非路由组件的区别
     1.路由组件一般放置在page|view文件夹下，非路由组件一般放置在components文件夹中
     2.路由组件一般需要在router文件下进行注册引入（引入即为组件的名字），非路由组件使用的时候，一般都是以标签的形式使用
     3.注册完路由，不管路由组件还是非路由组件身上都有$route,$router属性
       $route:一般获取路由信息【路径，query,params,props等】
        $router:一般进行编程式导航进行路由跳转【push|replace】
  2.路由的跳转？
     路由的跳转有两种形式：声明式导航router-link,可以进行路由的跳转
     编程式导航push|replace,可以进行路由跳转
     this.router.push({
      name:'',
      params:{
      }
    })
    this.router.replace({
      name:'',
      params:{
      }
    })
     编程式导航：声明式导航能做的编程式导航都能做
     编程式导航除了能做路由跳转，还能做其他的业务逻辑
3.Footer组件的显示与隐藏
   Footer组件：在Home.Search显示Footer组件
   Footer组件：在login,register不显示是隐藏的
  1.显示或者隐藏组件：v-if|v-show(推荐)
    方法1：我们可以根据组件身上的$route获取当前的路由信息,通过路由路径判断显示与隐藏
    方法2：添加路由元信息【meta:{show:true}】控制显示隐藏【$.router.meta.show】,路由需要配置对象，他的key不能胡写
4.路由传参
  1.路由的跳转有几种方式？
   2种：
   1.声明式导航：<router-link>一定要有to属性，可以实现路由的跳转
   2.编程式导航：利用组件实例的$router.push|replace方法，可以实现路由的跳转(在路由跳转之前可以书写业务，业务完成后再跳转)
  2.路由传参，参数有几种写法？
   两种
   1.params参数：属于路径当中的一部分，需要注意在配置路由的时候需要占位
   2.query参数:不属于路径当中的一部分，类似于ajax中的queryString /home?v=v&&v=v,不需要占位
## 路由传参相关面试题
   1.路由传递参数（对象写法）path是否可以结合params参数一起使用？
     答：路由跳转传参时，对象的写法可以是name,path形式，但是需要注意，path不能与params一起使用
   2.如何指定params参数可传可不传？
     比如：配置路由的时候，占位了（params参数），但是路由跳转的时候不传递参数就会出现问题
     如果路由要求传递params参数，如果不传，url就会出现问题
     解决params参数可以传递也可以不传递，就是在配置路由时占位后加上一个问号？，代表params参数传不传都可以
   3.params参数可以传递也可以不传递，但是如果传递是空串，应该如何解决？
   使用undefined解决params传递的是空字符串的问题
   // this.$router.push({
    name:'search',
    params:{
      keywords:'' || undefined
    }
   })
   4.路由组件能不能传递props数据？
   可以,有三种写法，一是布尔值，二是对象，三是函数

## day2
## 重写push,replace
   1.编程式路由跳转到当前路由，参数不变，多次执行会抛出NavigationDuplicated的警告错误？
   ----路由跳转有两种形式：声明式导航，编程式导航
   ----声明式导航没有这类问题，因为vue-router底层已经处理好了
   1.1为什么编程式路由导航就有这种警告错误？
      this.$router.push({})返回的结果是promise对象，promise对象需要有成功和失败的回调函数，如没有，就会报错，
      所以我们要想解决这个问题，就要传递成功和失败的回调
      this.$router.push({},()=>{},(err)=>{})
   1.2通过上面方法，治标不治本，将来在别的组件当中push|replace，编程 式导航还是有类似错误，我们需要重写replace|push方法去解决
   1.3
   this:当前组件实例对象
   push在组件实例的原型对象身上
   this.$router属性：当前的这个属性，属性值VueRouter类的一个实例，当在入口文件注册路由的时候，会给组件实例添加$router|$route属性
## home模块组件拆分
---静态页面
---拆分出静态组件
---获取服务器的数据展示
---动态业务
1.三级联动组件完成
---由于三级联动在Home,Search，Detail,都出现了，所以将其注册为全局组件
好处：只需注册一次，就可以在项目任意中使用
2.其余组件的拆分
拆分=结构+样式+图片资源

## POSTMAN测试接口
--通过postman测试接口并没有问题
--如果服务器返回的数据code字段503，代表服务器返回数据成功
--整个项目，接口前缀都有/api 
## axios的二次封装
XMLHttpRequest,fetch,JQ,axios
1.为什么要对axios进行二次封装？
  请求拦截器，响应拦截器
  请求拦截器：可以在发送请求之前处理一些业务
  响应拦截器：当服务器数据返回以后，可以处理一些事情
2.在项目中经常会出现API文件夹【放置axios】
 接口当中:路径都带有/api，给发i请求路径后都带上/api
  baseURL:'/api'
## 接口统一管理
项目很小：完全可以在组件的生命周期函数中发请求
项目大：axios.get('xxx')

2.跨域问题
协议，域名，端口号并不一致的请求，称为跨域
解决方案：JSPONP，代理服务器
## 进度条使用
要下载进度条，在封装axios的时候进行引入并引入css样式
在请求拦截器进行开始，相应拦截器结束
start:进度条开始
done:进度条结束
进度条颜色跨域修改

## vuex状态管理库
vuex是官方提供的一个插件，是一个状态管理库，进行集中式管理组件中共用的数据
state mutations actions gettters modules
vuex实现模块式开发

typeNav数据展示
1.完成一级分类动态添加背景颜色
第一种解决方案，采用样式完成
第二种解决方案
2.通过js控制二三级商品分类的显示和隐藏
最开始的时候，是通过css样式，dispaly,block|none来控制二三级分类的显示和隐藏
改为通过绑定样式和三元表达式来控制二三级分类的显示和隐藏
3.卡顿现象
事件触发非常频繁，而且每一次的触发，回调函数都要去执行
如果事件很短，而且回调函数内部有计算，那么很可能出现浏览器的卡卡顿现象
解决方法：节流，防抖
## 函数的防抖与节流
防抖：前面的所有的触发都被取消，最后一次执行在规定时间之后才会触发，也就是说如果连续快速的触发，只会执行一次
节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
防抖：虽然用户操作很频繁，但是最后只执行一次（回城）
节流：用户操作很频繁，但是把频繁的操作变为少量的操作，就可以给浏览器充足的时间解析代码（技能CD）
## 三级联动组件的路由跳转与传递参数
三级联动用户可以点击的：一级分类，二级分类，三级分类，当点击的时候，home模块跳转到search模块，一级会把用户选中的产品，在路由跳转的时候，进行传递
注意：如果使用声明式导航roter-link，可以实现路由的跳转与传递参数，但是会出现卡顿现象，
router-link是一个组件：当服务器的数据返回之后，循环出很多的router-link组件【创建组件实例】
创建组件实例的时候，一瞬间创建1000+，是很耗内存的，所以会出现卡顿现象
## 复习
（1）商品分类的三级列表由静态变为动态形式【获取服务器的数据，解决跨域问题】
（2）函数的防抖与节流
（3）路由的跳转：声明式导航（router-link是一个组件会出现卡顿现象），编程式导航（事件委派和自定义属性）
编程式导航采用的是自定义属性，自定义属性是以data开头，通过event.target中的dataset属性来获取自定义属性，自定义属性会将大写全都转为小写
（2）search模块中的typeNav商品分类菜单，过度动画效果
<!-- 显示或者隐藏东西使用v-show或者v-if -->
## 过渡动画
前提组件|元素必要有v-if或者v-show指令才能进行过度动画
## 商品分类进行优化
当进入home组件会发一次请求，转到search组件又发了一次
在app根组件中发请求，因为根组件mounted只执行一次
## 合并参数 ?
在typeNav与header发请求的时候进行判断
## 开发Home首页下的轮播图组件与FLoor组件？
但是这里需要知道一件事：服务器返回的数据（接口），只有商品分类数据，上面两种组件没有数据，需要模拟
mock数据（模拟数据）：如果想模拟数据，需要用一个mock插件
mock的数据只是自己模拟的数据，与后端发请求无关
使用步骤：
1.在src中创建mock
2.准备json数据（在mock文件夹中创建相应的json文件）
3.把mock数据需要的图片放置到public文件下中【public文件夹在打包的时候，会把相应的资源原封不动的打包到dist文件夹当中】
4.开始mock（虚拟数据），需要通过mockServer.js通过mock插件实现r
5.mockServer.js文件在入口文件中引入（至少执行一次，才能模拟数据）
注意：json格式的文件与图片是默认暴露的
## swiper listContainer组件开发重点
<!-- 安装Swiper插件：5版本 -->
步骤：
第一步：引包（相应js,css）
第二步：页面中结构务必要有
第三步：页面当中务必要有结构：new Swiper实例【轮播图添加动态效果】
## 复习
1.完成商品分类的三级列表路由跳转一级路由传参（合并参数）
2.完成search模块中对于typeNav的使用（过度动画）
3.对于typeNav请求次数进行优化（app.vue中）
4.swiper插件
swiper经常制作轮播图（移动端|pc端也可以使用）
<!-- 使用步骤
1.引入相应的依赖包（swiper.js,swiper.css)
2.页面中的结构必须要有
3.初始化swiper实例，给轮播图添加动态效果
 -->
5.mock数据，通过mockjs模块实现的

## 解决轮播图问题最完美的方案 watch+nextTick
通过watch数据监听：监听已有数据的变化
$nextTick:在下次DOM更新(向服务器请求回来数据之后)循环结束（v-for循环结束后）之后执行延迟回调。在修改数据之后（服务器数据返回后）立即使用这个方法，获取更新后的DOM
$nextTick可以保证页面中的结构(结构+数据)一定是有的，经常和很多插件一块使用,监听页面中出现异步语句的数据都已经请求回来了，结构已经存在了

## 开发floor组件
1.getFloorList这个actions在哪里触发?
在Home路由组件中发请求，不能在floor组件内部发请求，因为我们需要v-for遍历floor组件
2.v-for也可以在自定义标签中使用
3.组件通信的方式有哪些？
props：父子组件通信
自定义事件：@on @emit 子给父
全局事件总线：$bus 全能
pubsub-js:vue中几乎不用，全能
插槽
vuex
## 将首页当中轮播图拆分为一个共用全局组件
在开发项目的时候，如果在看到某一个组件在很多地方都使用，将他变为全局组件，这样的好处是，注册一次可以在任意地方使用，共用的组件|非路由组件放到components文件夹中

## search模块开发
1.将静态页面+静态组件拆分出来
2.发请求（API）发请求API时有两种一种是发get请求一种是post请求  reqrequests({url:'',method:'',data:''})  method:'get/post' ,若发送请求要携带参数则加上data:参数名
3.vuex(三连环)  若发请求携带参数，则在actions中异步发请求时也要携带参数
4.组件获取仓库数据，动态展示数据
## 复习
1.search模块需要的服务器的数据我们已经请求到了，而且存储于vuex的仓库中，而且有一些数组的数据已经通过getters进行简化
切记：getters是为了简化数据而生
2.商品列表，平台售卖属性已经动态数据（服务器数据）
## 面包屑
1.动态开发面包屑中的分类名
采用编程式路由跳转【自己跳自己】
2.动态开发面包屑中的关键字
2.1当面包屑中的关键字清除以后，需要让兄弟组件Header组件中的关键字清除
2.2采用编程式路由进行跳转
3.处理品牌信息
4.操作售卖属性
## 排序
排序方式 
1: 综合,2: 价格 asc: 升序,desc: 降序  
示例: "1:desc"
order属性的属性值最多有四种写法
1:asc 2:asc 1:desc 2:desc
2.考虑的问题
2.2谁应该有背景颜色的类名,通过order属性值包含1还是2
2.3 谁身上应该有箭头,谁有类名谁有箭头，箭头用案例图标库制作，先在index.html中引入，然后在组件中利用类名使用
## 分页器
1.为什么很多电商平台采用分页功能
可以提高电商平台的加载速度与性能，
2.分页器的展示需要哪些数据
2.1需要知道当前是第几页：pageNo表示当前页数
2.2需要知道每一页需要展示多少条数据：pagSize字段进行表示
2.3需要知道整个分页器一共有多少条数据：total字段进行表示【获取另外一条信息，一共有多少页】
2.4需要知道分页器连续的页码个数 5|7【奇数对称】
总结：
对于分页器而言，自定义的前提是需要知道四个前提条件
pagNo:当前第几页
pagSize:每页需要展示多少条数据
total:整个分页一共要展示多少条数据
continues:分页器连续页码个数
3.自定义分页器在开发的时候先自己传递假的数据进行调试，然后再使用服务器的数据
4.对于分页器而言，很重要的一个地方即为【算出连续页码的起始数字和结束数字】
5.分页器的动态展示
v-for:数组，数字，字符串，对象都可以遍历
## 分页器原理
1.需要的东西
  1.pageNo  当前第几页
  2.total   一共有多少页
  3.pageSize  每页展示多少条数据
    totalPage 一共有多少页Math.ceil() 向上取整
  4.continues  连续页码数
2.对于分页器
  当前页要在中间
3.考虑分页器的各种情况
  连续页码数（5）大于总页数
  特殊情况连续页码起始小于1（页码为1，2）

## 开发某一个产品的详情页面
1.静态组件(详情页的组件并未注册路由)
2.发请求（API）
3.vuex(新增一个detail仓库,然后回到大仓库中进行引入注入)
4.动态展示组件  getters简化数据时初始值为对象加{},初始值为数组加undefined
注意：当点击商品图片的时候，跳转到详情页面，但是在路由跳转的时候要带上产品的id给detail组件获取产品信息
## 数据解释
售卖属性：数组
## 排它
点谁谁亮

## 加入购物车
面试：防抖|节流，存储
1.路由跳转之前发请求
2.成功路由跳转与参数传递
3.失败提示失败信息
浏览器存储功能:HTML5中新增的   HTML5中新增哪些特性
本地存储:本地存储持久化---5M
会话存储:会随着浏览器关闭而消失(游客)

 ## 加入购物车
1.API(发请求获取不到购物车的数据,因为服务器不知道你是谁)
解决方法:重新建立一个uuid_token文件夹在里面封装一个函数对外暴露,使用uuid生成游客临时身份证明存储到本地存储里面,返回uuid_token,暴露给仓库,仓库中便可以获得uuid的数据,然后将uuid在服务器要发请求的时候加入到请求头里面,便可以解决谁的购物车问题
 2.vuex store
 动态展示购物车数据
 返回的数据有点不完美
3.修改购物车产品的数量(发请求)
4修改产品个数需要用到节流
4删除某一产品
6.修改产品状态
7。删除选中产品的全部操作
promise.all([p1,p2,p3])
数组里面都是promise对象
7全选

## 登录注册(git),必须要会的技能(处理共用图片资源问题)
1.准备静态组件
2.assets存放全部组件共用的静态资源
3.在样式当中也可以使用@符号，但是要在前面加上~
## 注册
1.注册业务或者登录业务中的表单验证先不处理
2.获取验证码接口/user/passport/sendCode/{phone}
## 登录
登录前提是注册，注册通过数据库存储用户信息
登录成功的时候，后台为了区分用户是谁，服务器result了data中有token[令牌：唯一的标识符（字符串）]
登录接口做的不完美：
一般登录成功服务器会下发token,前台进行持久化存储，【带着token找服务器要用户信息进行展示】
## token
当用户注册的时候给服务器信息，服务器接收到信息并存储到服务器中
当用户登录的时候，带着用户名与信息给服务器，服务器确认成功后下发一个token令牌
当用户再次登录的时候就要携带着这个令牌，给服务器识别，然后放行
注意：vuex仓库存储数据，不是持久化的
## 解决token令牌不持久化存储的问题
判断如果仓库中有token的话，就在请求拦截器中加入一个字段名为token进行存储
## 复习
1.完成了登录与注册的静态组件【assets文件夹存放所有组件共用的静态资源】
2.表单验证暂时没有处理
3.vuex存储数据是非持久化的
## 1.登录过后首页用户信息的展示，拿着token去要信息
/user/passport/auth/getUserInfo
## 复习
当用户注册完成，用户登录通过【用户名+密码】向服务器发请求（组件派发actions）,
登录成功，获得token--->存储仓库中（非持久化），路由跳转到home中
在home中派发action,获取用户信息，以及动态展示header组件内容
问题：一刷新，用户信息消失，原因：vuex是非持久化存储
## 持久化存储token（本地存储）
在用户登录成功之后进行setToken本地存储token，将token传递过去进行存储
新建一个token.js文件，存储在本地存储中，在仓库当中使用
## 存在的问题
1.多个组件要展示用户信息要在每一个组件的mounted中触发actions 
2.用户已经登录了，还可以跳转到登录页面
## 2.header组件显示用户名与退出登录
根据是否有用户名来判断显示与否，退出登录向服务器发i请求清除本地存储，与仓库中的数据
## 5.导航守卫 当路由发生跳转的时候要符合相应的条件
比如用户已经登陆，不应该再回到login页面
导航：表示路由正在发生改变，要进行路由跳转
守卫：门卫
### 6.全局守卫--前置，后置，解析
项目当中只要发生路由变化，守卫就能监听到

### 7.路由独享守卫

### 8.组件内守卫

## 9.交易页面
1.商品清单，地址
2动态展示服务器数据
3.提交订单
3.1静态
3.2向服务器发请求，将支付信息传递给服务器

获取支付信息
生命周期函数不能用async

4.使用element ui[pc] vant[移动端]
按照官方文档进行按需引入
5.二维码生成 qrcode

## center组件，以及子组件
element ui +qrcode 二维码  children:[{}]
## 个人中心完成
是否封装过组件：分页器
## 全局守卫
未登录访问，交易相关，支付相关，用户中新相关跳转到登录页面
点击上述路由登录后依然跳到上述路由中利用query参数，将要跳转的路由用变量存放起来，然后在login中再判断有五query参数，若有，跳query指定的路由，若没有，跳转到home首页
## 已登录
1.路由独享守卫
已登录访问:交易页，支付相关
## 图片懒加载
https://www.npmjs.com/package/vue-lazyload
## vee-validate 基本使用 表单验证
1.插件安装与引入
cnpm i vee-validate@2 --save 
import VeeValidate from 'vee-validate'
import zh_CN from 'vee-validate/dist/locale/zh_CN'
Vue.use(VeeValidate)

2.提示信息
VeeValidate.Validator.localize('zh_CN',{
  messages:{
    ...zh_CN.messages, //中文信息
    is:(field) =>`${field}`  //修改内置规则的message,让确认密码与密码相同
  },
  attributes:{  //给校验的field属性名映射中文名称
    phone:'手机号',
    code:'验证码',
    password:'密码',
    isCheck:'协议'
  }
})
3.基本使用
<input placeholder ="请输入你的手机号"
       v-model = "phone"
        <!-- 验证的是哪个 -->
       name = 'phone'  
       <!-- 自定义指令 -->
       v-validate = "{required:true,regex:/^1d{10}$/}"  
       :class="{invalid:errors.has('phone')}"
       />
<span class="error-msg">{{errors.first("phone")}}</span>
<!-- 自定义校验规则-----协议 -->
VeeValidate.Validator.extend('agree',{
  validate:value=>{
    return value
  },
  getMessage:field=>field + '必须同意'
})
## 路由懒加载
当打包构建应用时，js包会变得非常大，影响页面加载
如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了
只有路由被访问的时候才加载对应的组件
const foo = ()=> import('@/page/home')
## 打包上线
打包：npm run build
项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错
有了map就可以像未加密的代码一样，准确的输出是哪一行那一列的错
该文件在项目上线之前要去掉，节省打包体积
vue.config.js配置
productionSourceMap:false
## 购买服务器
阿里云 腾讯云

